#  宏
可做：
1. 宏定义 
2. 文件包含
3. 条件编译

----------
### 宏定义
``` c++
#define 标识符 内容
```
其中标识符就是宏的名称，预处理（预编译）工作就是将宏名替换为 内容。总原则**就地展开，没有运算**
例如：
```
#define PI 3.1415926
```
把程序中出现的PI全部换成3.1415926，
``` c++
#define S(r) r*r 
area=S(a+b); // area=a+b*a+b;
```
>说明
>1. 宏名一般用大写, 必须是合法的标识符, 规则遵循变量命名，替换时只替换标识符
>2. 内容部分中如果有引号（单、双）必须是完成的，不能出现半边，其他闭合符号如括号，大括号，没有硬性要求，只要展开后合乎语法即可。
>``` #define NAME "zhang //错误```
>``` #define NAME ("zhang" //可行```
>3. 宏定义末尾不加分号；
>4. 宏定义写在函数的花括号外边，作用域为**其后**的程序，通常在文件的最开头。
>5. 可以用#undef命令终止宏定义的作用域
>6. 宏定义允许嵌套，就是用定义过的宏名去定义另一个宏名，例如
>``` #define WIDTH 80 ```
> ```#define LENGTH (WIDTH+40)``` 
>7. 字符串( " " )中永远不包含宏， 例如
>``` #define a 80 ```
>``` " a " ```就是字符串``` " a " ```，不是``` " 80 " ```
>8. 宏定义不分配内存，变量定义分配内存。
>9. 宏定义不存在类型问题，它的参数也是无类型的。
> 10. 预处理是在编译之前的处理，而语法检查在编译工作中，所以预处理不做语法检查。
#### 特殊的``` # ```
由于引号(”“)中的内容不存在宏，所有下面的代码，得不到"345"，只能得到"a"
```
#define FUN(a) "a"
FUN(345) // "a"
```
如果想要转成字符串，就用到了特殊之```#```，
```
#define STR(str) #str
STR(345) // "345"
```
>说明
>1. STR()) 这样，编译器不会把“)”当成STR()的参数。
>2. STR(,) 同上，编译器不会把“,”当成STR的参数。
>3. STR(A,B)如果实参过多，则编译器报错。(g++ 5.4.0)
>4. STR((A,B))会被解读为实参为：(A,B)，而不是被解读为两个实参。
>5. 忽略传入参数名前面和后面的空格，
>``` STR( abc ) // "abc" not " abc "```

#### 特殊的``` ## ```
当想对传入的参数进行拼接时，实现下面的效果：
```
#define NEWTYPE(type, name) typedef type type_name
NEWTYPE(int, a) // 目标 typedef int int_a 结果  typedef int type_name
```
由于```type_name```被视为一个整体，并不能进行替换，这时就可以用```##```进行链接。
```
#define NEWTYPE(type, name) typedef type type##_##name
NEWTYPE(int, a) // 结果 typedef int int_a
```
>说明
>1. 宏展开顺序是从左向右，例如：
>```#define CONCAT(x,y) #x##y // 'x'y```
>``` #define CONCAT(x,y) #x###y // 'x''y' ```
>2. 多行的宏定义，在行结尾使用 \ 标明行未结束即可
